<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../iron-dropdown/iron-dropdown.html" />
<link rel="import" href="css/px-popover-styles.html" />

<!--
Simply place the the px-popover next to the element that you want it to attach to.
Set the 'for' attribute to the 'id' of the element that it's associated with. Then set
the 'popover-title' and 'popover-body' properties, and/or set `enhanced` and pass HTML
content as a child of the px-popover using 'slot=content'. The popover will automatically
grow to encapsulate the contents.

### Usage

    <div id="someElement">Some element</div>
    <px-popover for="someElement" orientation="bottom" popover-title="Bottom Popover" popover-body="Lorem ipsum"></px-popover>

    // Passing rich HTML content:
    <div id="someElement">Some element</div>
    <px-popover for="someElement" orientation="bottom" enhanced>
      <form slot="content"><label>This is a form<input class='text-input' type='text' value='Input'/></label></form>
    </px-popover>

### Styling

The following custom properties are available for styling:

Custom property | Description
:----------------|:-------------
`--px-popover-background-color` | Background color for the popover
`--px-popover-border-color` | Border color for the popover
`--px-popover-text-color` | Color for the text
`--px-popover-max-width` | Maximum width of the popover

@element px-popover
@homepage index.html
@demo index.html
-->
<dom-module id="px-popover">
  <template>
    <style include="px-popover-styles"></style>

    <iron-dropdown id="dropdown" with-backdrop="{{showOverlay}}" horizontal-align="left" vertical-align="top" dynamic-align="{{dynamicAlign}}" no-cancel-on-outside-click>
      <div slot="dropdown-content" id="popover">
        <template is="dom-if" if="{{!dynamicAlign}}">
        <div id="popover__carat" class$="{{orientation}}"></div>
        </template>
        <template is="dom-if" if="{{popoverTitle}}">
          <h5 class="epsilon">{{popoverTitle}}</h5>
        </template>
        <template is="dom-if" if="{{popoverBody}}">
          <p>{{popoverBody}}</p>
        </template>
        <template is="dom-if" if="{{enhanced}}">
          <slot name="content"></slot>
        </template>
      </div>
    </iron-dropdown>

  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-popover',
    properties: {
      /**
        * The id of the element that the tooltip is anchored to.
        * Should be a sibling of the px-popover.
        */
      for: {
        type: String,
        observer: '_forChanged'
      },
      /**
        * The direction that the popover is displayed relative to the
        * 'for' element.
        * - 'left' to the left of the 'for' element
        * - 'right' to the right of the 'for' element
        * - 'top' above the 'for' element
        * - 'bottom' below the 'for' element
        */
      orientation: {
        type: String,
        value: 'right'
      },
      /**
        * If the popover should attempt to align itself dynamically.
        * It will use the orientation you specify, unless there is not enough room,
        * in which case it will decide the orientation that causes the least cropping.
        * The caret will not be displayed for dynamically aligned popovers.
        */
        dynamicAlign: {
        type: Boolean,
        value: false
      },
      /**
        * The title that will be displayed in the popover.
        */
      popoverTitle: {
        type: String,
        value: ''
      },
      /**
        * The body text that will be displayed in the popover. Note: Does not support HTML elements within the body. Set `enhanced` and pass HTML as a child of the px-popover instead.
        */
      popoverBody: {
        type: String,
        value: ''
      },
      /**
        * By default, the overlay covering the rest of the screen is off.
        * This property should be set for mobile applications.
        */
      showOverlay: {
        type: Boolean,
        value: false,
        observer: '_showOverlayChanged'
      },
      /**
        * Enhanced empowers the developer to fully control the inner HTML of the popover. For instance, the popover can be used to render a form or contain an embedded video.
        * To inject your custom HTML, simply include your custom markup as the first child of the px-popover when declaring the px-popover in your application. Sample provided below.
        *
        *     <px-popover for="someElement" enhanced>
        *         <form>
        *            <label>This is a form
        *              <input type='text'/>
        *            </label>
        *         </form>
        *     </px-popover>
        */
      enhanced: {
        type: Boolean,
        value: false
      }
    },
    /**
      * Sets up listeners when popover is created
      */
    attached: function () {
      // Enable document-wide tap recognizer.
      Polymer.Gestures.add(document, 'tap', null);
      this._forChanged();
    },
    /**
      * Removes listeners when popover is destroyed
      */
    detached: function () {
      this.hideOverlayChanged(false);
    },
    _getTarget: function () {
      var ownerRoot = Polymer.dom(this).getOwnerRoot(),
        parentNode = Polymer.dom(this).parentNode,
        target;

      if (this.for && typeof (this.for) === 'string') {
        target = Polymer.dom(parentNode).querySelector('#' + this.for);
      }
      else if (this.for && typeof (this.for) === 'object') {
        target = this.for;
      }
      //DOCUMENT_FRAGMENT_NODE
      else if (parentNode.nodeType === 11) {
        //at this point if we can't find the actual owner root
        //we're probably not attached yet. Just set it to null
        //and wait for 'this' to be attached and rerun this function
        target = ownerRoot ? ownerRoot.host : null;
      }
      else {
        target = parentNode;
      }
      return target;
    },
    _forChanged: function () {
      if (this._target) {
        this.unlisten(this._target, 'tap', '_toggle');
        this.unlisten(this, 'tap', '_toggle');
        this._target.removeAttribute('slot');
      }

      this._target = this._getTarget();

      if (this._target) {
        this.listen(this._target, 'tap', '_toggle');
        this.listen(this, 'tap', '_toggle');
        this._target.slot = 'dropdown-trigger';
        this.$.dropdown.positionTarget = this._target;
      }
    },
    _isDescendant: function (parent, child) {
      var node = child.parentNode;
      while (node != null) {
        if (node === parent) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    },
    /**
      * Determines if event should yield a change in the popover visibility and sets up vars associated with the type of show event
      */
    _toggle: function (event) {
      // hide the popover if a click is coming from the outside
      if (event.type === 'tap') {
        if (this._isDescendant(this.$.popover__wrapper, event.target)) {
          return false;
        }
        else {
          if (event.target.id === this.for || this._isDescendant(document.querySelector('#' + this.for), event.target)) {
            this.show();
            return false;
          }
          else { // not our target
            if (this.$.dropdown.opened) {
              this.hide();
              return false;
            }
          }
        }
      }
    },
    _position: function (orientation, trigger) {
      if (orientation === 'right') {
        var hOffset = parseFloat(window.getComputedStyle(trigger).getPropertyValue('width'));
        var vOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('height')) / 2 * -1;
        this.$.dropdown.set('horizontalAlign', 'left');
        this.$.dropdown.set('verticalAlign', 'top');
        this.$.dropdown.set('horizontalOffset', hOffset);
        this.$.dropdown.set('verticalOffset', vOffset);
      }
      if (orientation === 'left') {
        var hOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('width')) * -1 - 15;
        var vOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('height')) / 2 * -1;
        this.$.dropdown.set('horizontalAlign', 'left');
        this.$.dropdown.set('verticalAlign', 'top');
        this.$.dropdown.set('horizontalOffset', hOffset);
        this.$.dropdown.set('verticalOffset', vOffset);
      }
      if (orientation === 'top') {
        var hOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('width')) / 2 * -1 + parseFloat(window.getComputedStyle(trigger).getPropertyValue('width')) / 2 - 10;
        var vOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('height')) * -1 - 15;
        this.$.dropdown.set('horizontalAlign', 'left');
        this.$.dropdown.set('verticalAlign', 'top');
        this.$.dropdown.set('horizontalOffset', hOffset);
        this.$.dropdown.set('verticalOffset', vOffset);
      }
      if (orientation === 'bottom') {
        var hOffset = parseFloat(window.getComputedStyle(this.$.popover).getPropertyValue('width')) / 2 * -1 + parseFloat(window.getComputedStyle(trigger).getPropertyValue('width')) / 2 - 10;
        var vOffset = parseFloat(window.getComputedStyle(trigger).getPropertyValue('height'));
        this.$.dropdown.set('horizontalAlign', 'left');
        this.$.dropdown.set('verticalAlign', 'top');
        this.$.dropdown.set('horizontalOffset', hOffset);
        this.$.dropdown.set('verticalOffset', vOffset);
      }
    },
    /**
      * Displays the popover
      */
    show: function () {
      this.$.dropdown.open();
      window.setTimeout(function () {
        this._position(this.orientation, this._target);
      }.bind(this), 50);
      this.fire('px-popover-show', {
        target: this
      });
    },
    /**
      * Hides the popover
      */
    hide: function () {
      this.$.dropdown.close();
      this.fire('px-popover-hide', {
        target: this
      });
    },
    /**
      * Adds and removes event listeners if the `hide-overlay` property is changed.
      */
      _showOverlayChanged: function(showOverlay) {

      if(showOverlay === true) {
        document.removeEventListener('touchend', this._onCaptureClick.bind(this));
        document.removeEventListener('click', this._onCaptureClick.bind(this));
      } else {
        document.addEventListener('touchend', this._onCaptureClick.bind(this), true);
        document.addEventListener('click', this._onCaptureClick.bind(this), true);
      }
    },
    /**
      * Called whenever a click happens if the overlay is hidden.
      * If the overlay is open and the click came from outside of
      * the popover, we hide it.
      */
      _onCaptureClick: function(evt) {
      if(this.$.dropdown.opened) {
        var path = Polymer.dom(evt).path,
            length = path.length,
            isPopover = false,
            i;
        for(i=0; i<length; i++) {
          if(path[i].id === 'popover') {
            isPopover = true;
            break;
          }
        }
        if(!isPopover) {
          this.hide();
        }
      }

    }
  });
</script>
